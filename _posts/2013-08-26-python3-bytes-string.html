---
layout: default
title: 从Python 3 的bytes/str 之别学编码Unicode
author: zzh
thisdate: 2013-08-26
classification: script 
---
<p id="fortitle"> {{ page.thisdate }} </p>
<h1>引子：bytes/str 之别</h1>
<pre class="preclass">
Python 3 最重要的新特性大概要算是对文本和二进制数据作了更为清晰的区分。文本总是Unicode，由str类型表示，二进制数据则由bytes类型表示。Python 3 不会以任意隐式的方式混用str和bytes，正是这使得两者的区分特别清晰。你不能拼接字符串和字节包，也无法在字节包里搜索字符串（反之亦然）， 也不能将字符串传入参数为字节包的函数（反之亦然）。这是件好事。不管怎样，字符串和字节包之间的界线是必然的，下面的图解非常重要，务请牢记于心：
<p class="addimg" id="bytes-string.png"></p>
字符串可以编码成字节包，而字节包可以解码成字符串。

>>> '€ 20'.encode('utf-8')
b'\xe2\x82\xac20'
>>> b'\xe2\x82\xac20'.decode('utf-8')
' € 20'

这个问题要这么来看：字符串是文本的抽象表示。字符串由字符组成，字符则是与任何特定二进制表示无关的抽象实体。在操作字符串时，我们生活在幸福的无知之中。我们可以对字符串进行分割和分片，可以拼接和搜索字符串。我们并不关心它们内部是怎么表示的，字符串里的每个字符要用几个字节保存。只有在将字符串编码成字节包（例如，为了在信道上发送它们）或从字节包
解码字符串（反向操作）时，我们才会开始关注这点。

传入encode 和decode 的参数是编码（或codec）。 编码是一种用二进制数据表示抽象字符的方式。目前有很多种编码。上面给出的UTF-8是其中一种，下面是另一种：

>>> '€ 20'.encode('iso-8859-15')
b'\xa420'
>>> b'\xa420'.decode('iso-8859-15')
' € 20'

编码是这个转换过程中至关重要的一部分。离了编码，bytes对象b'\xa420'只是一堆比特位而已。编码赋予其含义。采用不同的编码，这堆比特位的含义就会大不同：

>>> b'\xa420'.decode('windows-1255')
' ₪ 20'

据说百分之八十的金钱损失皆因使用错误的编码导致，因此务必小心谨慎。
</pre>
<h1>什么是编码</h1>
<pre class="preclass">
基本概念很简单。首先，我们从一段信息即消息说起，消息以人类可以理解、易懂的表示存在。我打算将这种表示称为“明文”（plain text ）。 于说英语的人，纸张上打印的或屏幕上显示的英文单词都算作明文。

其次，（原因稍候再述）我们需要能将明文表示的消息转成另外某种表示（不妨称之为“编码文本”，encoded text）， 我们还需要能将编码文本转回成明文。从明文到编码文本的转换称为“编码”，从编码文本又转回成明文则为“解码”。
<p class="addimg" id="bytes-string1.png"></p>
这个过程有三点很重要。

第一点是在编码或解码过程中不得丢失任何信息。我们必须能做到来回传递消息，从明文到编码文本，然后又从编码文本回到明文，取得的明文跟我们一开始拥有的完全一样。举例来说，这正是为什么我们无法用一种自然语言（俄语、汉语、法语、纳瓦霍语等）来编码另一种自然语言（英语、印地语、斯瓦西里语等）。 自然语言之间的映射关系太过松散，无法保证一条信息能在来回的转换中不失真。

要求来回转换不失真，也就意味着明文和编码文本之间的映射须又紧密又精确。这就引出了第二点。

为确保明文和编码文本之间的映射非常紧密，也即，为了能非常精确地规定编码和解码过程是怎么回事，我们必须非常精确地规定明文的表示是什么样的。

例如，假定我们的明文是这样的：英美字母表的26个大写字母，加上空格，及3 个标点符号：句点（句号）、 问号和短划线（连字符）。这就形成了30个字符的明文字母表。需要数字时，我们可以直接拼写出来，比如：six thousand seven hundred forty-three（六千七百四十三）。

另一方面，我们可能希望明文是这样的：26个大写字母，26个小写字母，10个数字，空格符，及十几种标点符号，包括句点、逗号、双引号、左括号、右括号等等。于是我们又得到一张75个字符的明文字母表。


一旦精确地规定了消息的明文表示是什么样的，比如上面的30个字符的字母表，也许是75个字符的字母表中有限的字符序列，我们就可以设计一套系统（编码，code）， 能对用这张字母表写成的明文消息进行可靠的编码和解码。这类系统最简单的一种是明文字母表里的每个字符在编码文本中有一个且只有一个对应的表示。举个大家都熟悉的摩尔斯电码的例子，其中明文“SOS”对应的编码文本为... --- ... 。

当然，在现实生活中，明文字母表中字符的选择受到编码文本上技术限制的影响。假定存储编码消息有如下几种技术可供选择：一种技术支持256 个字符的编码字母表，另一种技术只支持128个编码字符，第三种技术只支持64个编码字符。如果我们清楚自己可以使用支持更大编码文本字母表的技术，我们自然而然就能将明文字母表扩展得比以往大得多。

反之亦然。如果确定明文字母表一定要非常大，我们就会明白必须找到或设计一种能存储大量编码字符的技术。

这就引出了下面的话题，Unicode。
</pre>
<h1>Unicode</h1>
<pre class="preclass">
Unicode 的设计初衷是成为一套系统，可以存储现存所有人类语言的所有明文字符的编码表示。英语、法语、西班牙语、希腊语、阿拉伯语、印地语、汉语和亚述语（楔形文字）等。这些字符数量庞大。

因此，Unicode 计划的首要任务就是把所有这些字符罗列出来，数个数。这就是Unicode 的前半部分，通用字符集（Universal Character Set ）。（真正谈及Unicode 时，不要把明文字符叫做“字符”，称之为“码点”（code points）。）

完成前面的工作后，你还得想出一种技术，以储存全部对应的编码文本字符。（用Unicode 的话来说，编码文本字符被称作“码值”（code values）。）

实际上，Unicode 定义了不止一种方法，将码点映射到码值。这些方法都有自己的名字。其中部分名字以“UTF ”开头，其他以“UCS”开头：UTF-8 、UTF-16、UTF-32、UCS-2 、UCS-4 等等。命名规范是“UTF-< 码值的比特数>”和“UCS-< 码值的字节数>”。 有些方法（如UCS-4 和UTF-32）功能相若。参看维基百科Unicode 相关页面。

关于这些方法最重要的一点是，有些方法是定长编码，有些则是变长编码。基本思想是定长编码都很长，如UCS-4 和UTF-32都有4 字节（32比特）长，长到足以hold 住未来可期的最大码值。

相比而言，变长编码则设计成简短但可扩展。例如，UTF-8 可以使用少至8 比特（1 字节）来储存Latin和ASCII码点。不过，它还有一种“接下一个字节”机制，以便在必要时（有可能用来表示中文字符）可以使用2 个字节甚或4 个字节。对于西方国家的程序员，这就意味着UTF-8 既高效又灵活，UTF-8 之所以成为交换Unicode文本事实上的标准编码，原因正在于此。

总之，不存在所谓单一的Unicode 编码系统或方法，而是有好几种编码方法；打算跟别人交换文本时，你需要明确指定自己采用了哪种编码方法。

比如，是不是这样：
<p class="addimg" id="bytes-string2.png"></p>
或者这样：
<p class="addimg" id="bytes-string3.png"></p>
或者其他编码方法。
这又回到我前面提过的话题。
</pre>

<h1>为什么要用Unicode 来编码？</h1>
<pre class="preclass">
前文提到：
<pre class="codepre"><code>
首先，我们从一条信息即消息说起，消息以人类可以理解、易懂的表示存在。其次，（原因稍候再述）我们需要能将明文表示的消息转成另外某种表示（不妨称之为“编码文本”），我们还需要能将编码文本转回成明文。从明文到编码文本的转换称为“编码”，从编码文本又转回成明文则为“解码”。
</code></pre>
好的。现在是时候探讨这些原因了。为什么我们会想着将明文表示的消息转换成另一种表示呢？

一个原因当然是我们想要保密。我们想通过加密（encrypting）和解密（decrypting）来隐藏消息的明文，基本上编码和解码的算法要求保密和不扩散。

不过，这是个截然不同的主题。眼下，我们对保密不感兴趣；身为Python程序员，我们感兴趣的是Unicode。因此：
<pre class="codepre"><code>
身为Python程序员，为什么我会需要能将明文消息转换成某种编码表示……比如UTF-8 之类的Unicode 表示？
</code></pre>
假定你正舒舒服服地坐在电脑前，用你最喜欢的文本编辑器，用Python（特别是用Python 3+）编写标准的Hello World程序。你的整个程序只有下面这一行代码。

print("Hello, world!")

这里的“Hello, world!”就是明文。你在屏幕上看得见它。你可以阅读，明白它的含义。它就是一字符串，你可以对它执行字符串类型的标准操作，比如截取一个子串（切片）。

不过现在假定你准备将这个字符串“Hello, world!”放到一个文件中，并将该文件保存到硬盘上。也许你打算将这个文件发送给朋友。

这意味着你必须将那可怜瘦小的字符串逐出Python程序中温暖、和睦、安全的家，那里它就以明文字符的形式存在。你必须把它推入文件系统那阴冷、没有人情味的外部世界。那里它不会以字符的形式存在，只有1 和0，一堆杂乱的点点滴滴，充电和未充电的微粒。而这意味着原本幸福瘦小的明文字符串必须以1 和0 的某种特定配置来表示，这样一来，有人想要获取那组1 和0，将它转换回可读的明文，完全可以办到。

将明文转换成1 和0 的特定配置的过程就是编码的过程。为了将字符串写入文件中，你必须采用某种编码系统（比如UTF-8）对字符串进行编码。要从文件中取回字符串，你又必须读入文件，对这组1 和0 进行解码，转回成明文。

从文件读写字符串时需要对它进行编码和解码并不是新鲜事，这不是Python 3 对Unicode 的新支持引入的额外负担。其实你一直在做这件事。不过就是不怎么明显而已。较早版本的Python采用ASCII编码方案。因为在那些久远的年代，也只有ASCII这种编码方案，你不需要指定自己想要读写ASCII编码的文件。Python直接假定文件默认就采用ASCII，自动进行编码和界面。但是，无论你是否意识到这点，无论何时，只要你的程序从文件读写字符串，Python都会在幕后忙碌，为你完成编码和解码工作。

综上，这就是为什么身为Python程序员的你需要能将文本编码成UTF-8 （或其他某种编码：UTF-16、ASCII等）， 或将UTF-8 转回到文本。你需要将字符串编码成一组1 和0，这样才能将这些1 和0放进文件，然后将文件发送给其他人。
</pre>
<h1>什么是明文？</h1>
<pre class="preclass">
前面提到编码/ 解码过程有三点需要注意，我探讨了前面两点。下
面是第三点。

明文和编码文本之间的差别是相对的，且依赖语境。

作为程序员，我们会把书面文本当作明文。但也要从其他角度分析事物。例如，我们可以把口头文本看作明文，而书面文本看作编码文本。从这个角度来看，书面语是编码过的口语。世界上有很多种不同的编码，将口语编码成书面语。举例来说，有古埃及象形文字、玛雅象形文字、拉丁字母、希腊字母、阿拉伯文、中国的表意文字，还有非常平滑的天城文（Devanagari ）， 即使是简写体也呈锋利尖锐的楔形。这些都是口语词的书写编码。正如英国政治哲学家托马斯· 霍布斯（Thomas Hobbes）所言，它们都是“我们也许赖以记住我们思想的记号”。

这又提醒我们，在不同的语境中，即使言语本身——语言——也可能被看作是一种编码形式。在大部分早期现代哲学中（想想霍布斯和洛克），言语（或语言）基本上被认为是思想和理念的编码。当我将我的想法编码成语言说出口并对你说的时候，沟通就发生了。你听到我言语的声音，将其解码成想法。当我经由语言成功地将自己心里的想法传递到你心里的时候，我们的沟通也就成功了。由于我的言语，你心里的想法跟我心里的达成一致时，你便理解了我。（参看Ian Hacking 的Why Does Language Matter to Philosophy?）

最后，注意在其他语境中，“明文”甚至不是文本。明文是声波的（比如音乐）， 可以编码成mp3 文件。明文是图像的，可以编码为gif、png 或jpg 件。明文是电影的，可以编码成wmv文件。不一而足。

编码和解码无所不在。
</pre>
